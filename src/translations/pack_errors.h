// THIS FILE WAS GENERATED BY MSGMAP. DON'T TOUCH IT!
//
// Instead, edit its corresponding .yml files and run this
// project's msgmap script to generate new headers.

#ifndef _MSGMAP_pack_errors_TRANSLATIONS_H
#define _MSGMAP_pack_errors_TRANSLATIONS_H

#include "msgmap.h"

#include <wchar.h>

#ifndef _MSC_VER
    #error "msgmap: Wide character strings are only supported in MSVC"
#endif

typedef struct _mm_pack_errors_translations_t
{
    const wchar_t *no_pack_section;
    wchar_t *(*non_relative_path)(const wchar_t *path);
    wchar_t *(*quoted_path)(const wchar_t *path);
    wchar_t *(*upwards_path)(const wchar_t *path);
    wchar_t *(*nonexistent_file)(const wchar_t *path);
    wchar_t *(*file_path_is_dir)(const wchar_t *path);
    wchar_t *(*expand_environ_failed)(const wchar_t *path);
    wchar_t *(*extern_relative_path)(const wchar_t *path);
    wchar_t *(*invalid_option_value)(unsigned int value, const wchar_t *option);
    wchar_t *(*value_not_int)(const wchar_t *value);
    wchar_t *(*negative_int_value)(int value);
    wchar_t *(*garbage_after_int)(const wchar_t *str);
    wchar_t *(*option_no_equal)(const wchar_t *str);
    wchar_t *(*os_too_old)(unsigned int pack_build, unsigned int user_build);
    wchar_t *(*os_too_new)(unsigned int pack_build, unsigned int user_build);
    wchar_t *(*duplicate_option)(const wchar_t *option);
    wchar_t *(*unexpected_section)(const wchar_t *name);
    wchar_t *(*option_arg_no_key)(const wchar_t *arg);
    wchar_t *(*option_arg_no_value)(const wchar_t *arg);
    wchar_t *(*option_arg_bad_name)(const wchar_t *arg, const wchar_t *name);
    wchar_t *(*option_arg_non_number_value)(const wchar_t *arg, const wchar_t *value);
    wchar_t *(*option_arg_bad_value)(const wchar_t *arg, const wchar_t *value);
    wchar_t *(*invalid_bool_value)(unsigned int value);
} mm_pack_errors_translations_t;

MM_DEC const mm_pack_errors_translations_t *mm_get_pack_errors_translations(void);

#ifdef MSGMAP_IMPL

// en_US strings

static wchar_t *mm_pack_errors_translations_non_relative_path_en_US(const wchar_t *path)
{
    MM_FORMATTED_STRING_BODY_W(L"Encountered non-relative path '%s'", path)
}

static wchar_t *mm_pack_errors_translations_quoted_path_en_US(const wchar_t *path)
{
    MM_FORMATTED_STRING_BODY_W(L"Encountered path with quotes '%s'", path)
}

static wchar_t *mm_pack_errors_translations_upwards_path_en_US(const wchar_t *path)
{
    MM_FORMATTED_STRING_BODY_W(L"Encountered path with upwards directory traversal '%s'", path)
}

static wchar_t *mm_pack_errors_translations_nonexistent_file_en_US(const wchar_t *path)
{
    MM_FORMATTED_STRING_BODY_W(L"File at path '%s' doesn't exist.", path)
}

static wchar_t *mm_pack_errors_translations_file_path_is_dir_en_US(const wchar_t *path)
{
    MM_FORMATTED_STRING_BODY_W(L"Path '%s' points to a directory, not a file.", path)
}

static wchar_t *mm_pack_errors_translations_expand_environ_failed_en_US(const wchar_t *path)
{
    MM_FORMATTED_STRING_BODY_W(L"Failed to expand environment variables for path '%s'", path)
}

static wchar_t *mm_pack_errors_translations_extern_relative_path_en_US(const wchar_t *path)
{
    MM_FORMATTED_STRING_BODY_W(L"Relative path '%s' for external file encountered", path)
}

static wchar_t *mm_pack_errors_translations_invalid_option_value_en_US(unsigned int value, const wchar_t *option)
{
    MM_FORMATTED_STRING_BODY_W(L"Invalid value %u for option '%s'.", value, option)
}

static wchar_t *mm_pack_errors_translations_value_not_int_en_US(const wchar_t *value)
{
    MM_FORMATTED_STRING_BODY_W(L"'%s' is not an integer", value)
}

static wchar_t *mm_pack_errors_translations_negative_int_value_en_US(int value)
{
    MM_FORMATTED_STRING_BODY_W(L"Negative integer value %d", value)
}

static wchar_t *mm_pack_errors_translations_garbage_after_int_en_US(const wchar_t *str)
{
    MM_FORMATTED_STRING_BODY_W(L"Garbage characters after number string '%s'", str)
}

static wchar_t *mm_pack_errors_translations_option_no_equal_en_US(const wchar_t *str)
{
    MM_FORMATTED_STRING_BODY_W(L"Missing '=' in option string '%s'", str)
}

static wchar_t *mm_pack_errors_translations_os_too_old_en_US(unsigned int pack_build, unsigned int user_build)
{
    MM_FORMATTED_STRING_BODY_W(L"This pack was designed for at minimum Windows build %u. You are running build %u.", pack_build, user_build)
}

static wchar_t *mm_pack_errors_translations_os_too_new_en_US(unsigned int pack_build, unsigned int user_build)
{
    MM_FORMATTED_STRING_BODY_W(L"This pack was designed for at maximum Windows build %u. You are running build %u.", pack_build, user_build)
}

static wchar_t *mm_pack_errors_translations_duplicate_option_en_US(const wchar_t *option)
{
    MM_FORMATTED_STRING_BODY_W(L"Duplicate option '%s'", option)
}

static wchar_t *mm_pack_errors_translations_unexpected_section_en_US(const wchar_t *name)
{
    MM_FORMATTED_STRING_BODY_W(L"Unexpected section with name '%s'", name)
}

static wchar_t *mm_pack_errors_translations_option_arg_no_key_en_US(const wchar_t *arg)
{
    MM_FORMATTED_STRING_BODY_W(L"Improperly formed option argument '%s'. It must specify a key and value in the format '/option:key=value'.\n\nFor example, '/option:Files=1'.", arg)
}

static wchar_t *mm_pack_errors_translations_option_arg_no_value_en_US(const wchar_t *arg)
{
    MM_FORMATTED_STRING_BODY_W(L"Improperly formed option argument '%s'. No value specified.", arg)
}

static wchar_t *mm_pack_errors_translations_option_arg_bad_name_en_US(const wchar_t *arg, const wchar_t *name)
{
    MM_FORMATTED_STRING_BODY_W(L"Improperly formed option argument '%s'. Invalid option name '%s' specified.", arg, name)
}

static wchar_t *mm_pack_errors_translations_option_arg_non_number_value_en_US(const wchar_t *arg, const wchar_t *value)
{
    MM_FORMATTED_STRING_BODY_W(L"Improperly formed option argument '%s'. Option value '%s' could not be parsed as a number.", arg, value)
}

static wchar_t *mm_pack_errors_translations_option_arg_bad_value_en_US(const wchar_t *arg, const wchar_t *value)
{
    MM_FORMATTED_STRING_BODY_W(L"Improperly formed option argument '%s'. Invalid option value %s specified.", arg, value)
}

static wchar_t *mm_pack_errors_translations_invalid_bool_value_en_US(unsigned int value)
{
    MM_FORMATTED_STRING_BODY_W(L"Invalid boolean value %u.", value)
}

static const mm_pack_errors_translations_t mm_pack_errors_translations_en_US = {
    L"No 'Pack' section found", // no_pack_section
    mm_pack_errors_translations_non_relative_path_en_US,
    mm_pack_errors_translations_quoted_path_en_US,
    mm_pack_errors_translations_upwards_path_en_US,
    mm_pack_errors_translations_nonexistent_file_en_US,
    mm_pack_errors_translations_file_path_is_dir_en_US,
    mm_pack_errors_translations_expand_environ_failed_en_US,
    mm_pack_errors_translations_extern_relative_path_en_US,
    mm_pack_errors_translations_invalid_option_value_en_US,
    mm_pack_errors_translations_value_not_int_en_US,
    mm_pack_errors_translations_negative_int_value_en_US,
    mm_pack_errors_translations_garbage_after_int_en_US,
    mm_pack_errors_translations_option_no_equal_en_US,
    mm_pack_errors_translations_os_too_old_en_US,
    mm_pack_errors_translations_os_too_new_en_US,
    mm_pack_errors_translations_duplicate_option_en_US,
    mm_pack_errors_translations_unexpected_section_en_US,
    mm_pack_errors_translations_option_arg_no_key_en_US,
    mm_pack_errors_translations_option_arg_no_value_en_US,
    mm_pack_errors_translations_option_arg_bad_name_en_US,
    mm_pack_errors_translations_option_arg_non_number_value_en_US,
    mm_pack_errors_translations_option_arg_bad_value_en_US,
    mm_pack_errors_translations_invalid_bool_value_en_US,
};

static const mm_translation_mapping_t mm_pack_errors_map[] = {
    { (void *)&mm_pack_errors_translations_en_US, "en", "US" },
};

MM_IMPL const mm_pack_errors_translations_t *mm_get_pack_errors_translations(void)
{
    return (const mm_pack_errors_translations_t *)mm_get_translations(mm_pack_errors_map, 1);
}

#endif // MSGMAP_IMPL

#endif // _MSGMAP_pack_errors_TRANSLATIONS_H